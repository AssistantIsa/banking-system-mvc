from flask import Flask, jsonify, request
from werkzeug.security import generate_password_hash, check_password_hash
import jwt
from datetime import datetime, timedelta
from functools import wraps
import psycopg2
from psycopg2.extras import RealDictCursor
from decimal import Decimal
import os
from dotenv import load_dotenv

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'clave-secreta-por-defecto')

DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'database': os.getenv('DB_NAME', 'banking_db'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASSWORD', 'admin1234'),  # IMPORTANTE: Cambia esto
    'port': os.getenv('DB_PORT', 5432)
}
# MIDDLEWARE CORS
@app.before_request
def handle_options():
    if request.method == 'OPTIONS':
        response = app.make_default_options_response()
        headers = response.headers
        headers['Access-Control-Allow-Origin'] = '*'
        headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
        headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        return response

@app.after_request
def add_cors_headers(response):
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
    return response

# Decorator para rutas protegidas con JWT
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        if 'Authorization' in request.headers:
            token = request.headers['Authorization'].split(' ')[1]
        
        if not token:
            return jsonify({'message': 'Token no proporcionado'}), 401
        
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
            current_user_id = data['user_id']
        except:
            return jsonify({'message': 'Token inválido'}), 401
        
        return f(current_user_id, *args, **kwargs)
    
    return decorated

# Función helper para conectar a la BD
def get_db_connection():
    conn = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
    return conn

# RUTAS

@app.route('/api/health', methods=['GET'])
def health():
    return jsonify({"status": "healthy", "database": "postgresql"})

@app.route('/api/register', methods=['POST'])
def register():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    email = data.get('email')
    
    if not username or not password or not email:
        return jsonify({'message': 'Faltan campos requeridos'}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Verificar si el usuario ya existe
        cursor.execute('SELECT * FROM users WHERE username = %s OR email = %s', (username, email))
        if cursor.fetchone():
            return jsonify({'message': 'Usuario o email ya existe'}), 409
        
        # Hash del password
        password_hash = generate_password_hash(password)
        
        # Insertar usuario
        cursor.execute(
            'INSERT INTO users (username, password_hash, email) VALUES (%s, %s, %s) RETURNING user_id',
            (username, password_hash, email)
        )
        user_id = cursor.fetchone()['user_id']
        
        # Crear cuenta de ahorros por defecto
        cursor.execute(
            'INSERT INTO accounts (owner_id, account_type, balance) VALUES (%s, %s, %s)',
            (user_id, 'Ahorros', 1000.00)
        )
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({'message': 'Usuario registrado exitosamente', 'user_id': user_id}), 201
        
    except Exception as e:
        return jsonify({'message': f'Error al registrar usuario: {str(e)}'}), 500

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')
    
    if not username or not password:
        return jsonify({'message': 'Faltan credenciales'}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM users WHERE username = %s', (username,))
        user = cursor.fetchone()
        
        cursor.close()
        conn.close()
        
        if not user or not check_password_hash(user['password_hash'], password):
            return jsonify({'message': 'Credenciales inválidas'}), 401
        
        # Generar JWT token
        token = jwt.encode({
            'user_id': user['user_id'],
            'username': user['username'],
            'exp': datetime.utcnow() + timedelta(hours=24)
        }, app.config['SECRET_KEY'], algorithm="HS256")
        
        return jsonify({
            'message': 'Login exitoso',
            'token': token,
            'user': {
                'user_id': user['user_id'],
                'username': user['username'],
                'email': user['email']
            }
        }), 200
        
    except Exception as e:
        return jsonify({'message': f'Error en login: {str(e)}'}), 500

@app.route('/api/accounts', methods=['GET'])
@token_required
def get_accounts(current_user_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT account_number, account_type, balance, is_active, created_at 
            FROM accounts 
            WHERE owner_id = %s AND is_active = TRUE
        ''', (current_user_id,))
        
        accounts = cursor.fetchall()
        
        cursor.close()
        conn.close()
        
        # Convertir Decimal a float para JSON
        accounts_list = []
        for acc in accounts:
            accounts_list.append({
                'account_number': acc['account_number'],
                'account_type': acc['account_type'],
                'balance': float(acc['balance']),
                'is_active': acc['is_active'],
                'created_at': acc['created_at'].isoformat()
            })
        
        return jsonify({'accounts': accounts_list}), 200
        
    except Exception as e:
        return jsonify({'message': f'Error al obtener cuentas: {str(e)}'}), 500

@app.route('/api/transfer', methods=['POST'])
@token_required
def transfer(current_user_id):
    data = request.get_json()
    from_account = data.get('from_account')
    to_account = data.get('to_account')
    amount = data.get('amount')
    description = data.get('description', 'Transferencia')
    
    if not from_account or not to_account or not amount:
        return jsonify({'message': 'Faltan datos requeridos'}), 400
    
    if float(amount) <= 0:
        return jsonify({'message': 'El monto debe ser mayor a 0'}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Verificar que la cuenta origen pertenece al usuario
        cursor.execute('SELECT * FROM accounts WHERE account_number = %s AND owner_id = %s', 
                      (from_account, current_user_id))
        source_account = cursor.fetchone()
        
        if not source_account:
            return jsonify({'message': 'Cuenta origen no válida'}), 403
        
        # Verificar saldo suficiente
        if float(source_account['balance']) < float(amount):
            return jsonify({'message': 'Saldo insuficiente'}), 400
        
        # Verificar que la cuenta destino existe
        cursor.execute('SELECT * FROM accounts WHERE account_number = %s', (to_account,))
        dest_account = cursor.fetchone()
        
        if not dest_account:
            return jsonify({'message': 'Cuenta destino no existe'}), 404
        
        # Realizar la transferencia (transacción atómica)
        cursor.execute('UPDATE accounts SET balance = balance - %s WHERE account_number = %s', 
                      (amount, from_account))
        cursor.execute('UPDATE accounts SET balance = balance + %s WHERE account_number = %s', 
                      (amount, to_account))
        
        # Registrar la transacción
        cursor.execute('''
            INSERT INTO transactions (from_account_id, to_account_id, amount, transaction_type, description)
            VALUES (%s, %s, %s, %s, %s)
        ''', (from_account, to_account, amount, 'Transferencia', description))
        
        conn.commit()
        cursor.close()
        conn.close()
        
        return jsonify({
            'message': 'Transferencia exitosa',
            'transaction': {
                'from_account': from_account,
                'to_account': to_account,
                'amount': float(amount),
                'description': description
            }
        }), 200
        
    except Exception as e:
        conn.rollback()
        return jsonify({'message': f'Error en transferencia: {str(e)}'}), 500

@app.route('/api/transactions', methods=['GET'])
@token_required
def get_transactions(current_user_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Obtener todas las cuentas del usuario
        cursor.execute('SELECT account_number FROM accounts WHERE owner_id = %s', (current_user_id,))
        user_accounts = [acc['account_number'] for acc in cursor.fetchall()]
        
        if not user_accounts:
            return jsonify({'transactions': []}), 200
        
        # Obtener transacciones
        placeholders = ','.join(['%s'] * len(user_accounts))
        query = f'''
            SELECT t.transaction_id, t.from_account_id, t.to_account_id, 
                   t.amount, t.transaction_type, t.description, t.timestamp
            FROM transactions t
            WHERE t.from_account_id IN ({placeholders}) 
               OR t.to_account_id IN ({placeholders})
            ORDER BY t.timestamp DESC
            LIMIT 50
        '''
        
        cursor.execute(query, user_accounts + user_accounts)
        transactions = cursor.fetchall()
        
        cursor.close()
        conn.close()
        
        # Formatear transacciones
        transactions_list = []
        for trans in transactions:
            transactions_list.append({
                'transaction_id': trans['transaction_id'],
                'from_account': trans['from_account_id'],
                'to_account': trans['to_account_id'],
                'amount': float(trans['amount']),
                'type': trans['transaction_type'],
                'description': trans['description'],
                'timestamp': trans['timestamp'].isoformat()
            })
        
        return jsonify({'transactions': transactions_list}), 200
        
    except Exception as e:
        return jsonify({'message': f'Error al obtener transacciones: {str(e)}'}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8888, debug=True)
